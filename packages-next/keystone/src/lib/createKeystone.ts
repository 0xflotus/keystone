import path from 'path';
import { Keystone } from '@keystonejs/keystone';
import { MongooseAdapter } from '@keystonejs/adapter-mongoose';
import { KnexAdapter } from '@keystonejs/adapter-knex';
// @ts-ignore
import { PrismaAdapter } from '@keystonejs/adapter-prisma';
import {
  KeystoneConfig,
  BaseKeystone,
  getGqlNames,
  ListForExperiment,
  BaseKeystoneList,
} from '@keystone-next/types';
import pluralize from 'pluralize';
import { Migrate } from '@prisma/migrate';
import { getGenerator } from '@prisma/sdk';
import { generatePrismaSchemaFromModels, getGraphQLSchema } from '../../../keystone-experiment/src';
import fs from 'fs-extra';

const upcase = (str: string) => str.substr(0, 1).toUpperCase() + str.substr(1);

const keyToLabel = (str: string) => {
  let label = str
    .replace(/([a-z])([A-Z])/g, '$1 $2')
    .split(/\s|_|\-/)
    .filter(i => i)
    .map(upcase)
    .join(' ');

  // Retain the leading underscore for auxiliary lists
  if (str[0] === '_') {
    label = `_${label}`;
  }
  return label;
};

const labelToPath = (str: string) => str.split(' ').join('-').toLowerCase();

const labelToClass = (str: string) => str.replace(/\s+/g, '');

export function createKeystone(
  config: KeystoneConfig,
  dotKeystonePath: string,
  script: string
): BaseKeystone {
  if (config.db.adapter === 'experimental') {
    const { graphql, lists } = config;
    const migrationMode =
      script === 'prototype'
        ? ('prototype' as const)
        : script === 'generate'
        ? ('createOnly' as const)
        : script === 'start'
        ? ('none' as const)
        : ('dev' as const);

    const keystone: BaseKeystone = {
      _consolidateRelationships: () => undefined as any,
      adapter: {},
      async connect() {
        if (migrationMode !== 'dev') {
          throw new Error("only migrationMode: 'dev' is implemented");
        }
        const schemaPath = 'schema/schema.prisma';

        let prismaSchema = generatePrismaSchemaFromModels(listsForExperiment);

        fs.outputFileSync(schemaPath, prismaSchema);

        console.log('wrote prisma schema');
        const migrate = new Migrate(schemaPath);

        await migrate.push({ force: true });

        console.log('pushed schema to database');

        let generator = await getGenerator({ schemaPath });

        await generator.generate();

        console.log('generated client');
        // eslint-disable-next-line import/no-extraneous-dependencies
        const { PrismaClient } = require('@prisma/client');
        this.adapter.prisma = new PrismaClient();
      },
      async disconnect() {},
      lists: {},
      queryLimits: { maxTotalResults: config.graphql?.queryLimits?.maxTotalResults || 0 },
      createApolloServer() {},
      createList(): any {},
      getResolvers() {},
      getTypeDefs() {},
    };

    Object.entries(lists).forEach(([key, { graphql /*access, hooks, description*/, fields }]) => {
      const _label = /*label || */ keyToLabel(key);
      const _singular = /*singular || */ pluralize.singular(_label);
      const _plural = /*plural || */ pluralize.plural(_label);

      if (_plural === _label) {
        throw new Error(
          `Unable to use ${_label} as a List name - it has an ambiguous plural (${_plural}). Please choose another name for your list.`
        );
      }

      const adminUILabels = {
        // Fall back to the plural for the label if none was provided, not the autogenerated default from key
        label: /*label || */ _plural,
        singular: _singular,
        plural: _plural,
        path: labelToPath(_plural),
      };

      const itemQueryName = graphql?.itemQueryName || labelToClass(_singular);
      const listQueryName = graphql?.listQueryName || labelToClass(_plural);

      const notImplemented = () => {
        throw new Error('not implemented');
      };
      const fieldsByPath = Object.fromEntries(
        Object.entries(fields).map(([fieldPath]: any): [
          string,
          BaseKeystoneList['fields'][number]
        ] => {
          return [
            fieldPath,
            {
              getBackingTypes() {
                return {};
              },
              isOrderable: false,
              label: fieldPath,
              gqlCreateInputFields() {},
            },
          ];
        })
      );
      keystone.lists[key] = {
        createManyMutation: notImplemented,
        createMutation: notImplemented,
        deleteManyMutation: notImplemented,
        adminUILabels,
        deleteMutation: notImplemented,
        itemQuery({ where }, context) {
          return context.prisma[key[0].toLowerCase() + key.slice(1)].findUnique({
            where,
          });
        },
        listQuery: notImplemented,
        key,
        listQueryMeta: notImplemented,
        updateManyMutation: notImplemented,
        updateMutation: notImplemented,
        gqlNames: getGqlNames({ listKey: key, itemQueryName, listQueryName }),
        fields: Object.values(fieldsByPath),
        fieldsByPath,
        adapter: { itemsQuery: undefined as any },
      };
    });

    const listsForExperiment: Record<string, ListForExperiment> = Object.fromEntries(
      Object.entries(keystone.lists).map(
        ([
          listKey,
          {
            gqlNames: { listQueryName },
          },
        ]) => {
          return [
            listKey,
            {
              pluralGraphQLName: listQueryName.replace('all', ''),
              fields: Object.fromEntries(
                Object.entries(
                  config.lists[listKey].fields
                ).map(([fieldPath, { experimental }]: any) => [fieldPath, experimental])
              ),
            },
          ];
        }
      )
    );

    (keystone as any).graphQLSchema = getGraphQLSchema(listsForExperiment);

    return keystone;
  }
  // Note: For backwards compatibility we may want to expose
  // this as a public API so that users can start their transition process
  // by using this pattern for creating their Keystone object before using
  // it in their existing custom servers or original CLI systems.
  const { db, graphql, lists } = config;
  let adapter;
  if (db.adapter === 'knex') {
    adapter = new KnexAdapter({
      knexOptions: { connection: db.url },
      dropDatabase: db.dropDatabase,
    });
  } else if (db.adapter === 'mongoose') {
    adapter = new MongooseAdapter({ mongoUri: db.url, ...db.mongooseOptions });
  } else if (db.adapter === 'prisma_postgresql') {
    adapter = new PrismaAdapter({
      getPrismaPath: () => path.join(dotKeystonePath, 'prisma'),
      migrationMode:
        script === 'prototype'
          ? 'prototype'
          : script === 'generate'
          ? 'createOnly'
          : script === 'start'
          ? 'none'
          : 'dev',
      ...db,
    });
  }
  // @ts-ignore The @types/keystonejs__keystone package has the wrong type for KeystoneOptions
  const keystone: BaseKeystone = new Keystone({
    adapter,
    cookieSecret: '123456789', // FIXME: Don't provide a default here. See #2882
    queryLimits: graphql?.queryLimits,
    // @ts-ignore The @types/keystonejs__keystone package has the wrong type for KeystoneOptions
    onConnect: (keystone, { context } = {}) => config.db.onConnect?.(context),
    // FIXME: Unsupported options: Need to work which of these we want to support with backwards
    // compatibility options.
    // defaultAccess
    // sessionStore
    // cookie
    // schemaNames
    // appVersion
  });

  Object.entries(lists).forEach(([key, { fields, graphql, access, hooks, description }]) => {
    keystone.createList(key, {
      fields: Object.fromEntries(
        Object.entries(fields).map(([key, { type, config }]: any) => [key, { type, ...config }])
      ),
      access,
      queryLimits: graphql?.queryLimits,
      schemaDoc: graphql?.description ?? description,
      listQueryName: graphql?.listQueryName,
      itemQueryName: graphql?.itemQueryName,
      hooks,
      // FIXME: Unsupported options: Need to work which of these we want to support with backwards
      // compatibility options.
      // adminDoc
      // labelResolver
      // labelField
      // adminConfig
      // label
      // singular
      // plural
      // path
      // adapterConfig
      // cacheHint
      // plugins
    });
  });

  return keystone;
}
